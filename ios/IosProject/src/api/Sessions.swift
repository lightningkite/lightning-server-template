// Package: com.lightningkite.template.api
// Generated by Khrysalis - this file will be overwritten.
import KhrysalisRuntime
import RxSwift
import LightningServer
import RxSwiftPlus
import Foundation

public class AbstractAnonymousSession {
    public var api: Api
    public init(_ api: Api) {
        self.api = api
        self.auth = AbstractAnonymousSessionAuthApi(api: api.auth)
        self.user = AbstractAnonymousSessionUserApi(api: api.user)
        self.fcmToken = AbstractAnonymousSessionFcmTokenApi(api: api.fcmToken)
        //Necessary properties should be initialized now
    }
    
    public let auth: AbstractAnonymousSessionAuthApi
    public let user: AbstractAnonymousSessionUserApi
    public let fcmToken: AbstractAnonymousSessionFcmTokenApi
    public func uploadFileForRequest() -> Single<UploadInformation> {
        return self.api.uploadFileForRequest();
    }
    public class AbstractAnonymousSessionAuthApi {
        public var api: ApiAuthApi
        public init(api: ApiAuthApi) {
            self.api = api
            //Necessary properties should be initialized now
        }
        
        public func anonymousToken() -> Single<String> {
            return self.api.anonymousToken(userToken: nil);
        }
        public func emailLoginLink(input: String) -> Single<Void> {
            return self.api.emailLoginLink(input: input);
        }
        public func emailPINLogin(input: EmailPinLogin) -> Single<String> {
            return self.api.emailPINLogin(input: input);
        }
    }
    public class AbstractAnonymousSessionUserApi {
        public var api: ApiUserApi
        public init(api: ApiUserApi) {
            self.api = api
            //Necessary properties should be initialized now
        }
        
        public func `default`() -> Single<User> {
            return self.api.`default`(userToken: nil);
        }
        public func query(input: Query<User>) -> Single<Array<User>> {
            return self.api.query(input: input, userToken: nil);
        }
        public func detail(id: UUID) -> Single<User> {
            return self.api.detail(id: id, userToken: nil);
        }
        public func insertBulk(input: Array<User>) -> Single<Array<User>> {
            return self.api.insertBulk(input: input, userToken: nil);
        }
        public func insert(input: User) -> Single<User> {
            return self.api.insert(input: input, userToken: nil);
        }
        public func upsert(id: UUID, input: User) -> Single<User> {
            return self.api.upsert(id: id, input: input, userToken: nil);
        }
        public func bulkReplace(input: Array<User>) -> Single<Array<User>> {
            return self.api.bulkReplace(input: input, userToken: nil);
        }
        public func replace(id: UUID, input: User) -> Single<User> {
            return self.api.replace(id: id, input: input, userToken: nil);
        }
        public func bulkModify(input: MassModification<User>) -> Single<Int> {
            return self.api.bulkModify(input: input, userToken: nil);
        }
        public func modifyWithDiff(id: UUID, input: Modification<User>) -> Single<EntryChange<User>> {
            return self.api.modifyWithDiff(id: id, input: input, userToken: nil);
        }
        public func modify(id: UUID, input: Modification<User>) -> Single<User> {
            return self.api.modify(id: id, input: input, userToken: nil);
        }
        public func bulkDelete(input: Condition<User>) -> Single<Int> {
            return self.api.bulkDelete(input: input, userToken: nil);
        }
        public func delete(id: UUID) -> Single<Void> {
            return self.api.delete(id: id, userToken: nil);
        }
        public func count(input: Condition<User>) -> Single<Int> {
            return self.api.count(input: input, userToken: nil);
        }
        public func groupCount(input: GroupCountQuery<User>) -> Single<Dictionary<String, Int>> {
            return self.api.groupCount(input: input, userToken: nil);
        }
        public func aggregate(input: AggregateQuery<User>) -> Single<Double?> {
            return self.api.aggregate(input: input, userToken: nil);
        }
        public func groupAggregate(input: GroupAggregateQuery<User>) -> Single<Dictionary<String, Double?>> {
            return self.api.groupAggregate(input: input, userToken: nil);
        }
        public func watch() -> Observable<WebSocketIsh<ListChange<User>, Query<User>>> {
            return self.api.watch(userToken: nil);
        }
    }
    public class AbstractAnonymousSessionFcmTokenApi {
        public var api: ApiFcmTokenApi
        public init(api: ApiFcmTokenApi) {
            self.api = api
            //Necessary properties should be initialized now
        }
        
    }
}

public class AbstractUserSession {
    public init(_ api: Api, userToken: String) {
        self.auth = UserSessionAuthApi(api: api.auth, userToken: userToken)
        self.user = UserSessionUserApi(api: api.user, userToken: userToken)
        self.fcmToken = UserSessionFcmTokenApi(api: api.fcmToken, userToken: userToken)
        //Necessary properties should be initialized now
    }
    
    public var api: Api { get { TODO() } }
    public var userToken: String { get { TODO() } }
    public let auth: UserSessionAuthApi
    public let user: UserSessionUserApi
    public let fcmToken: UserSessionFcmTokenApi
    public func uploadFileForRequest() -> Single<UploadInformation> {
        return self.api.uploadFileForRequest();
    }
    public func getServerHealth() -> Single<ServerHealth> {
        return self.api.getServerHealth(userToken: self.userToken);
    }
    public final class UserSessionAuthApi {
        public var api: ApiAuthApi
        public var userToken: String
        public init(api: ApiAuthApi, userToken: String) {
            self.api = api
            self.userToken = userToken
            //Necessary properties should be initialized now
        }
        
        public func refreshToken() -> Single<String> {
            return self.api.refreshToken(userToken: self.userToken);
        }
        public func getSelf() -> Single<User> {
            return self.api.getSelf(userToken: self.userToken);
        }
        public func anonymousToken() -> Single<String> {
            return self.api.anonymousToken(userToken: self.userToken);
        }
        public func emailLoginLink(input: String) -> Single<Void> {
            return self.api.emailLoginLink(input: input);
        }
        public func emailPINLogin(input: EmailPinLogin) -> Single<String> {
            return self.api.emailPINLogin(input: input);
        }
    }
    public final class UserSessionUserApi {
        public var api: ApiUserApi
        public var userToken: String
        public init(api: ApiUserApi, userToken: String) {
            self.api = api
            self.userToken = userToken
            //Necessary properties should be initialized now
        }
        
        public func `default`() -> Single<User> {
            return self.api.`default`(userToken: self.userToken);
        }
        public func query(input: Query<User>) -> Single<Array<User>> {
            return self.api.query(input: input, userToken: self.userToken);
        }
        public func detail(id: UUID) -> Single<User> {
            return self.api.detail(id: id, userToken: self.userToken);
        }
        public func insertBulk(input: Array<User>) -> Single<Array<User>> {
            return self.api.insertBulk(input: input, userToken: self.userToken);
        }
        public func insert(input: User) -> Single<User> {
            return self.api.insert(input: input, userToken: self.userToken);
        }
        public func upsert(id: UUID, input: User) -> Single<User> {
            return self.api.upsert(id: id, input: input, userToken: self.userToken);
        }
        public func bulkReplace(input: Array<User>) -> Single<Array<User>> {
            return self.api.bulkReplace(input: input, userToken: self.userToken);
        }
        public func replace(id: UUID, input: User) -> Single<User> {
            return self.api.replace(id: id, input: input, userToken: self.userToken);
        }
        public func bulkModify(input: MassModification<User>) -> Single<Int> {
            return self.api.bulkModify(input: input, userToken: self.userToken);
        }
        public func modifyWithDiff(id: UUID, input: Modification<User>) -> Single<EntryChange<User>> {
            return self.api.modifyWithDiff(id: id, input: input, userToken: self.userToken);
        }
        public func modify(id: UUID, input: Modification<User>) -> Single<User> {
            return self.api.modify(id: id, input: input, userToken: self.userToken);
        }
        public func bulkDelete(input: Condition<User>) -> Single<Int> {
            return self.api.bulkDelete(input: input, userToken: self.userToken);
        }
        public func delete(id: UUID) -> Single<Void> {
            return self.api.delete(id: id, userToken: self.userToken);
        }
        public func count(input: Condition<User>) -> Single<Int> {
            return self.api.count(input: input, userToken: self.userToken);
        }
        public func groupCount(input: GroupCountQuery<User>) -> Single<Dictionary<String, Int>> {
            return self.api.groupCount(input: input, userToken: self.userToken);
        }
        public func aggregate(input: AggregateQuery<User>) -> Single<Double?> {
            return self.api.aggregate(input: input, userToken: self.userToken);
        }
        public func groupAggregate(input: GroupAggregateQuery<User>) -> Single<Dictionary<String, Double?>> {
            return self.api.groupAggregate(input: input, userToken: self.userToken);
        }
        public func watch() -> Observable<WebSocketIsh<ListChange<User>, Query<User>>> {
            return self.api.watch(userToken: self.userToken);
        }
    }
    public final class UserSessionFcmTokenApi {
        public var api: ApiFcmTokenApi
        public var userToken: String
        public init(api: ApiFcmTokenApi, userToken: String) {
            self.api = api
            self.userToken = userToken
            //Necessary properties should be initialized now
        }
        
        public func `default`() -> Single<FcmToken> {
            return self.api.`default`(userToken: self.userToken);
        }
        public func query(input: Query<FcmToken>) -> Single<Array<FcmToken>> {
            return self.api.query(input: input, userToken: self.userToken);
        }
        public func detail(id: String) -> Single<FcmToken> {
            return self.api.detail(id: id, userToken: self.userToken);
        }
        public func insertBulk(input: Array<FcmToken>) -> Single<Array<FcmToken>> {
            return self.api.insertBulk(input: input, userToken: self.userToken);
        }
        public func insert(input: FcmToken) -> Single<FcmToken> {
            return self.api.insert(input: input, userToken: self.userToken);
        }
        public func upsert(id: String, input: FcmToken) -> Single<FcmToken> {
            return self.api.upsert(id: id, input: input, userToken: self.userToken);
        }
        public func bulkReplace(input: Array<FcmToken>) -> Single<Array<FcmToken>> {
            return self.api.bulkReplace(input: input, userToken: self.userToken);
        }
        public func replace(id: String, input: FcmToken) -> Single<FcmToken> {
            return self.api.replace(id: id, input: input, userToken: self.userToken);
        }
        public func bulkModify(input: MassModification<FcmToken>) -> Single<Int> {
            return self.api.bulkModify(input: input, userToken: self.userToken);
        }
        public func modifyWithDiff(id: String, input: Modification<FcmToken>) -> Single<EntryChange<FcmToken>> {
            return self.api.modifyWithDiff(id: id, input: input, userToken: self.userToken);
        }
        public func modify(id: String, input: Modification<FcmToken>) -> Single<FcmToken> {
            return self.api.modify(id: id, input: input, userToken: self.userToken);
        }
        public func bulkDelete(input: Condition<FcmToken>) -> Single<Int> {
            return self.api.bulkDelete(input: input, userToken: self.userToken);
        }
        public func delete(id: String) -> Single<Void> {
            return self.api.delete(id: id, userToken: self.userToken);
        }
        public func count(input: Condition<FcmToken>) -> Single<Int> {
            return self.api.count(input: input, userToken: self.userToken);
        }
        public func groupCount(input: GroupCountQuery<FcmToken>) -> Single<Dictionary<String, Int>> {
            return self.api.groupCount(input: input, userToken: self.userToken);
        }
        public func aggregate(input: AggregateQuery<FcmToken>) -> Single<Double?> {
            return self.api.aggregate(input: input, userToken: self.userToken);
        }
        public func groupAggregate(input: GroupAggregateQuery<FcmToken>) -> Single<Dictionary<String, Double?>> {
            return self.api.groupAggregate(input: input, userToken: self.userToken);
        }
        public func watch() -> Observable<WebSocketIsh<ListChange<FcmToken>, Query<FcmToken>>> {
            return self.api.watch(userToken: self.userToken);
        }
    }
}


