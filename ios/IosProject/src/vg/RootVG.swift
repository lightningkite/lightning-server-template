// Package: com.lightningkite.template.vg
// Generated by Khrysalis - this file will be overwritten.
import KhrysalisRuntime
import RxSwift
import UIKit
import LightningServer
import RxSwiftPlus
import Foundation

public final class RootVG : ViewGenerator, EntryPoint, ForegroundNotificationHandler {
    public init() {
        self.dialog = ValueSubject([])
        self.root = ValueSubject([])
        //Necessary properties should be initialized now
        Companion.INSTANCE.instance = self
        let serverName = PreferenceKeys.INSTANCE.server
        let option = serverName.flatMap { temp189 in ({ (it) -> ServerOption? in ServerOptions.INSTANCE.getOptionByName(name: it) })(temp189) }
        let jwt = PreferenceKeys.INSTANCE.session
        if let option = option, let jwt = jwt {
            self.login(server: option, token: jwt)
                .doOnSubscribe { (it) -> Void in self.dialog.reset(LoadingDialogVG()) }
                .doFinally { () -> Void in self.dialog.value = [] }
                .subscribe(onSuccess: { (it) -> Void in  }, onError: { (it) -> Void in
                it.printStackTrace()
                showDialog(message: R.string.generic_error)
                self.loginAction()
            })
        } else {
            self.loginAction()
        }
    }
    
    public func handleNotificationInForeground(_ map: Dictionary<String, String>) -> ForegroundNotificationHandlerResult {
        return ForegroundNotificationHandlerResult.ShowNotification
    }
    
    public func onBackPressed() -> Bool {
        return self.dialog.backPressPop() || self.mainStack.backPressPop()
    }
    
    public final class Companion {
        public init() {
            //Necessary properties should be initialized now
        }
        public static let INSTANCE = Companion()
        
        public var instance: (RootVG)!
    }
    
    
    
    public func handleDeepLink(schema: String, host: String, path: String, params: Dictionary<String, String>) -> Void {
        print("Handling deep link!")
        print("\(String(kotlin: schema))://\(String(kotlin: host))\(String(kotlin: path))?\(String(kotlin: params.joined(separator: "&", transform: { (it) -> String in it.key + "=" + it.value })))")
        
        let option = ServerOptions.INSTANCE.availableServers.first(where: { (it) -> Bool in (it.api.httpUrl.indexOf(params["server"] ?? "*NEVER*") != -1) })
        
        if let jwt = (params["jwt"]) {
            print("OPTION: \(option)")
            if option == nil {
                showDialog(message: R.string.deep_link_was_invalid_server)
            } else {
                self.login(server: option!, token: jwt)
                    .doOnSubscribe { (it) -> Void in self.dialog.reset(LoadingDialogVG()) }
                    .doFinally { () -> Void in self.dialog.value = [] }
                    .subscribe(onSuccess: { (it) -> Void in  }, onError: { (it) -> Void in showDialog(message: R.string.deep_link_was_invalid_credentials) })
            }
        }
        
    }
    
    public func login(server: ServerOption, token: String?) -> Single<Void> {
        return run { () -> Single<Void> in
            if token == nil {
                self.root.reset(SessionVG(root: self.mainStack, session: Session(anon: AnonymousSession(server.api), user: nil)))
                return Single.just(())
            } else {
                let session = UserSession(server.api, userToken: token!)
                return session.api.auth.getSelf(userToken: session.userToken).doOnSuccess { (user) -> Void in
                    PreferenceKeys.INSTANCE.server = server.name
                    PreferenceKeys.INSTANCE.session = token
                    if user.termsAgreed > Date.distantPast {
                        self.dialog.value = []
                        self.root.reset(SessionVG(root: self.mainStack, session: Session(anon: AnonymousSession(server.api), user: session)))
                    } else {
                        self.root.push(TermsVG { () -> Void in
                            session.api.user.modify(id: user._id, input: modification(setup: { (it) -> Modification<User> in it.termsAgreed.assign(Date()) }), userToken: token)
                                .subscribe(onSuccess: { (it) -> Void in print(it) }, onError: { (it) -> Void in it.printStackTrace() })
                            self.dialog.value = []
                            self.root.reset(SessionVG(root: self.mainStack, session: Session(anon: AnonymousSession(server.api), user: session)))
                        })
                    }
                }.map { (it) -> Void in () }
            }
        }
    }
    
    public let dialog: ValueSubject<Array<ViewGenerator>>
    
    public let root: ValueSubject<Array<ViewGenerator>>
    
    public var mainStack: ValueSubject<Array<ViewGenerator>> {
        get { return self.root }
    }
    
    public func generate(dependency: ViewControllerAccess) -> UIView {
        
        let xml = RootBinding()
        
        //--- Set Up xml.content (overwritten on flow generation)
        self.root.showIn(xml.content, dependency: dependency)
        
        //--- Set Up xml.backButton
        let showBackButton = self.root.map { (it) -> Bool in it.count > 1 }
        showBackButton.subscribeAutoDispose(xml.backButton, (\UIButton.visible))
        showBackButton.subscribeAutoDispose(xml.backButton, \UIControl.isEnabled)
        xml.backButton.onClick { () -> Void in self.backButtonClick() }
        
        //--- Set Up xml.dialog (overwritten on flow generation)
        self.dialog.showIn(xml.dialog, dependency: dependency)
        
        //--- Generate End (overwritten on flow generation)
        
        return xml.root
    }
    
    
    
    //--- Actions
    
    public func backButtonClick() -> Void {
        self.root.backPressPop()
    }
    
    
    //--- Action sessionAction
    
    public func loginAction() -> Void {
        self.root.reset(LandingVG(root: self.root, stack: self.root))
    }
    
    public func logOut(_ session: Session) -> Void {
        if let it = (session.user) {
            if let token = (Notifications.INSTANCE.notificationToken.value) {
                it.fcmToken.bulkDelete(input: condition(setup: { (it) -> Condition<FcmToken> in it._id.eq(token) }))
                    .subscribe(onSuccess: { (it) -> Void in  }, onError: { (it) -> Void in  })
            }
        }
        SecurePreferences.clear()
        self.loginAction()
    }
    
    //--- Body End
}

