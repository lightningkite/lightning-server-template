// Package: com.lightningkite.template
// Generated by Khrysalis - this file will be overwritten.
import KhrysalisRuntime
import LightningServer
import Foundation

public final class User : HasId, HasEmail, CustomStringConvertible, Hashable, PropertyIterable, Codable {
    public typealias ID = UUID
    public var _id: UUID
    public var email: String
    public var termsAgreed: Date
    public var isSuperUser: Bool
    public var subscriptionId: String?
    public var customerId: String?
    public init(_id: UUID = UUID.randomUUID(), email: String, termsAgreed: Date = Date.distantPast, isSuperUser: Bool = false, subscriptionId: String? = nil, customerId: String? = nil) {
        self._id = _id
        self.email = email
        self.termsAgreed = termsAgreed
        self.isSuperUser = isSuperUser
        self.subscriptionId = subscriptionId
        self.customerId = customerId
        //Necessary properties should be initialized now
    }
    convenience required public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.init(
            _id: values.contains(._id) ? try values.decode(UUID.self, forKey: ._id) : UUID.randomUUID(),
            email: try values.decode(String.self, forKey: .email),
            termsAgreed: values.contains(.termsAgreed) ? try values.decode(Date.self, forKey: .termsAgreed) : Date.distantPast,
            isSuperUser: values.contains(.isSuperUser) ? try values.decode(Bool.self, forKey: .isSuperUser) : false,
            subscriptionId: values.contains(.subscriptionId) ? try values.decode(String?.self, forKey: .subscriptionId) : nil,
            customerId: values.contains(.customerId) ? try values.decode(String?.self, forKey: .customerId) : nil
        )
    }
    
    enum CodingKeys: String, CodingKey {
        case _id = "_id"
        case email = "email"
        case termsAgreed = "termsAgreed"
        case isSuperUser = "isSuperUser"
        case subscriptionId = "subscriptionId"
        case customerId = "customerId"
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self._id, forKey: ._id)
        try container.encode(self.email, forKey: .email)
        try container.encode(self.termsAgreed, forKey: .termsAgreed)
        try container.encode(self.isSuperUser, forKey: .isSuperUser)
        try container.encodeIfPresent(self.subscriptionId, forKey: .subscriptionId)
        try container.encodeIfPresent(self.customerId, forKey: .customerId)
    }
    
    public func hash(into hasher: inout Hasher) {
        hasher.combine(_id)
        hasher.combine(email)
        hasher.combine(termsAgreed)
        hasher.combine(isSuperUser)
        hasher.combine(subscriptionId)
        hasher.combine(customerId)
        
    }
    public static func == (lhs: User, rhs: User) -> Bool { return lhs._id == rhs._id && lhs.email == rhs.email && lhs.termsAgreed == rhs.termsAgreed && lhs.isSuperUser == rhs.isSuperUser && lhs.subscriptionId == rhs.subscriptionId && lhs.customerId == rhs.customerId }
    public var description: String { return "User(_id=\(String(kotlin: self._id)), email=\(String(kotlin: self.email)), termsAgreed=\(String(kotlin: self.termsAgreed)), isSuperUser=\(String(kotlin: self.isSuperUser)), subscriptionId=\(String(kotlin: self.subscriptionId)), customerId=\(String(kotlin: self.customerId)))" }
    public static let _idProp: PropertyIterableProperty<User, UUID> = PropertyIterableProperty(name: "_id", path: \._id, setCopy: { (this, value) in this.copy(_id: value) })
    public static let emailProp: PropertyIterableProperty<User, String> = PropertyIterableProperty(name: "email", path: \.email, setCopy: { (this, value) in this.copy(email: value) })
    public static let termsAgreedProp: PropertyIterableProperty<User, Date> = PropertyIterableProperty(name: "termsAgreed", path: \.termsAgreed, setCopy: { (this, value) in this.copy(termsAgreed: value) })
    public static let isSuperUserProp: PropertyIterableProperty<User, Bool> = PropertyIterableProperty(name: "isSuperUser", path: \.isSuperUser, setCopy: { (this, value) in this.copy(isSuperUser: value) })
    public static let subscriptionIdProp: PropertyIterableProperty<User, String?> = PropertyIterableProperty(name: "subscriptionId", path: \.subscriptionId, setCopy: { (this, value) in this.copy(subscriptionId: value) })
    public static let customerIdProp: PropertyIterableProperty<User, String?> = PropertyIterableProperty(name: "customerId", path: \.customerId, setCopy: { (this, value) in this.copy(customerId: value) })
    public static let properties: Array<PartialPropertyIterableProperty<User>> = [_idProp, emailProp, termsAgreedProp, isSuperUserProp, subscriptionIdProp, customerIdProp]
    public static var anyProperties: Array<AnyPropertyIterableProperty> { return properties.map { $0 } }
    public func copy(_id: UUID? = nil, email: String? = nil, termsAgreed: Date? = nil, isSuperUser: Bool? = nil, subscriptionId: String?? = .some(nil), customerId: String?? = .some(nil)) -> User { return User(_id: _id ?? self._id, email: email ?? self.email, termsAgreed: termsAgreed ?? self.termsAgreed, isSuperUser: isSuperUser ?? self.isSuperUser, subscriptionId: invertOptional(subscriptionId) ?? self.subscriptionId, customerId: invertOptional(customerId) ?? self.customerId) }
}

public final class FcmToken : HasId, CustomStringConvertible, Hashable, PropertyIterable, Codable {
    public typealias ID = String
    public var _id: String
    public var user: UUID
    public init(_id: String, user: UUID) {
        self._id = _id
        self.user = user
        //Necessary properties should be initialized now
    }
    convenience required public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.init(
            _id: try values.decode(String.self, forKey: ._id),
            user: try values.decode(UUID.self, forKey: .user)
        )
    }
    
    enum CodingKeys: String, CodingKey {
        case _id = "_id"
        case user = "user"
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self._id, forKey: ._id)
        try container.encode(self.user, forKey: .user)
    }
    
    public func hash(into hasher: inout Hasher) {
        hasher.combine(_id)
        hasher.combine(user)
        
    }
    public static func == (lhs: FcmToken, rhs: FcmToken) -> Bool { return lhs._id == rhs._id && lhs.user == rhs.user }
    public var description: String { return "FcmToken(_id=\(String(kotlin: self._id)), user=\(String(kotlin: self.user)))" }
    public static let _idProp: PropertyIterableProperty<FcmToken, String> = PropertyIterableProperty(name: "_id", path: \._id, setCopy: { (this, value) in this.copy(_id: value) })
    public static let userProp: PropertyIterableProperty<FcmToken, UUID> = PropertyIterableProperty(name: "user", path: \.user, setCopy: { (this, value) in this.copy(user: value) })
    public static let properties: Array<PartialPropertyIterableProperty<FcmToken>> = [_idProp, userProp]
    public static var anyProperties: Array<AnyPropertyIterableProperty> { return properties.map { $0 } }
    public func copy(_id: String? = nil, user: UUID? = nil) -> FcmToken { return FcmToken(_id: _id ?? self._id, user: user ?? self.user) }
}

