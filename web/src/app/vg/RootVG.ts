// Package: com.lightningkite.template.vg
// Generated by Khrysalis - this file will be overwritten.
import { Strings } from '../../resources/R'
import { RootBinding } from '../../resources/layouts/RootBinding'
import { xPropChain_idGet } from '../../shared/FcmTokenFields'
import { xPropChainTermsAgreedGet } from '../../shared/UserFields'
import { FcmToken, User } from '../../shared/models'
import { ServerOption, ServerOptions } from '../api/ServerOptions'
import { AnonymousSession, Session, UserSession } from '../models/UserSession'
import { PreferenceKeys } from '../utils/PreferenceKeys'
import { getSecurePreferences } from '../utils/preferences'
import { LandingVG } from './LandingVG'
import { LoadingDialogVG } from './LoadingDialogVG'
import { SessionVG } from './SessionVG'
import { TermsVG } from './TermsVG'
import { Instant } from '@js-joda/core'
import { join, printStackTrace, runOrNull } from '@lightningkite/khrysalis-runtime'
import { Condition, Modification, PropChain, condition, modification, xPropChainAssign, xPropChainEq } from '@lightningkite/lightning-server'
import { EntryPoint, ViewGenerator, ViewGeneratorStack, doOnSubscribe, not, onThrottledEventDo, reverse, showDialog, showInSwapCustom, subscribeAutoDispose, viewVisible, xStackBackPressPop, xStackPush, xStackReset } from '@lightningkite/rxjs-plus'
import { ForegroundNotificationHandler, ForegroundNotificationHandlerResult, Notifications } from '@lightningkite/rxjs-plus/fcm'
import { execPipe, findOr, map } from 'iter-tools-es'
import { BehaviorSubject, Observable, SubscriptionLike, of } from 'rxjs'
import { finalize, map as oMap, tap } from 'rxjs/operators'

//! Declares com.lightningkite.template.vg.RootVG
export class RootVG implements ViewGenerator, EntryPoint, ForegroundNotificationHandler {
    public static implementsViewGenerator = true;
    public static implementsEntryPoint = true;
    public static implementsHasBackAction = true;
    public static implementsForegroundNotificationHandler = true;
    public constructor() {
        RootVG.Companion.INSTANCE.instance = this;
        this.dialog = new BehaviorSubject([]);
        this.root = new BehaviorSubject([]);
        const serverName = PreferenceKeys.INSTANCE.server;;
        const option = ((): (ServerOption | null) => {
            if (serverName === null || serverName === undefined) { return null }
            return ((it: string): (ServerOption | null) => (ServerOptions.INSTANCE.getOptionByName(it)))(serverName)
        })();;
        const jwt = PreferenceKeys.INSTANCE.session;;
        if (option !== null && jwt !== null) {
            this.login(option!, jwt)
                .pipe(doOnSubscribe((it: SubscriptionLike): void => {
                xStackReset(this.dialog, new LoadingDialogVG());
            }))
                .pipe(finalize((): void => {
                this.dialog.next([]);
            }))
                .subscribe((it: void): void => {}, (it: any): void => {
                printStackTrace(it);
                showDialog(Strings.generic_error);
                this.loginAction();
            });
        } else {
            this.loginAction();
        };
    }
    
    public handleNotificationInForeground(map: Map<string, string>): ForegroundNotificationHandlerResult {
        return ForegroundNotificationHandlerResult.ShowNotification;
    }
    
    public onBackPressed(): boolean {
        return xStackBackPressPop(this.dialog) || xStackBackPressPop(this.mainStack);
    }
    
    
    
    
    
    public handleDeepLink(schema: string, host: string, path: string, params: Map<string, string>): void {
        console.log("Handling deep link!");
        console.log(`${schema}://${host}${path}?${execPipe(new Set([...params.entries()]), map((it: [string, string]): string => (it[0] + "=" + it[1])), join("&"))}`);
        
        const option = findOr(null, (it: ServerOption): boolean => ((it.api.httpUrl.toLowerCase().indexOf((params.get("server") ?? null) ?? "*NEVER*".toLowerCase()) != -1)), ServerOptions.INSTANCE.availableServers);
        
        const jwt_31 = (params.get("jwt") ?? null);
        if (jwt_31 !== null) {
            console.log(`OPTION: ${option}`);
            if (option === null) {
                showDialog(Strings.deep_link_was_invalid_server);
            } else {
                this.login(option!, jwt_31)
                    .pipe(doOnSubscribe((it: SubscriptionLike): void => {
                    xStackReset(this.dialog, new LoadingDialogVG());
                }))
                    .pipe(finalize((): void => {
                    this.dialog.next([]);
                }))
                    .subscribe((it: void): void => {}, (it: any): void => {
                    showDialog(Strings.deep_link_was_invalid_credentials);
                });
            }
        }
        
    }
    
    public login(server: ServerOption, token: (string | null)): Observable<void> {
        return ((): Observable<void> => {
            if (token === null) {
                xStackReset(this.root, new SessionVG(this.mainStack, new Session(new AnonymousSession(server.api), null)));
                return of(undefined);
            } else {
                const session = new UserSession(server.api, token!);
                return session.api.auth.getSelf(session.userToken).pipe(tap((user: User): void => {
                    PreferenceKeys.INSTANCE.server = server.name;
                    PreferenceKeys.INSTANCE.session = token;
                    if (user.termsAgreed.compareTo(Instant.EPOCH) > 0) {
                        this.dialog.next([]);
                        xStackReset(this.root, new SessionVG(this.mainStack, new Session(new AnonymousSession(server.api), session)));
                    } else {
                        xStackPush(this.root, new TermsVG((): void => {
                            session.api.user.modify(user._id, modification<User>((it: PropChain<User, User>): Modification<User> => (xPropChainAssign<User, Instant>(xPropChainTermsAgreedGet(it), Instant.now()))), token)
                                .subscribe((it: User): void => {
                                    console.log(it);
                                }, (it: any): void => {
                                    printStackTrace(it);
                            });
                            this.dialog.next([]);
                            xStackReset(this.root, new SessionVG(this.mainStack, new Session(new AnonymousSession(server.api), session)));
                        }));
                    }
                })).pipe(oMap((it: User): void => {
                    return undefined;
                }));
            }
        })();
    }
    
    public readonly dialog: ViewGeneratorStack;
    
    public readonly root: ViewGeneratorStack;
    
    //! Declares com.lightningkite.template.vg.RootVG.mainStack
    public get mainStack(): ViewGeneratorStack { return this.root; }
    
    
    public generate(dependency: Window): HTMLElement {
        
        const xml = RootBinding.inflate();
        
        //--- Set Up xml.content (overwritten on flow generation)
        this.root.pipe(showInSwapCustom(xml.content, dependency, undefined));
        
        //--- Set Up xml.backButton
        const showBackButton = this.root.pipe(oMap((it: Array<ViewGenerator>): boolean => (it.length > 1)));
        showBackButton.pipe(subscribeAutoDispose(xml.backButton, viewVisible));
        showBackButton.pipe(subscribeAutoDispose(xml.backButton, reverse("disabled", not)));
        onThrottledEventDo(xml.backButton, 'click', (): void => {
            this.backButtonClick();
        });
        
        //--- Set Up xml.dialog (overwritten on flow generation)
        this.dialog.pipe(showInSwapCustom(xml.dialog, dependency, undefined));
        
        //--- Generate End (overwritten on flow generation)
        
        return xml.root;
    }
    
    
    
    //--- Actions
    
    public backButtonClick(): void {
        xStackBackPressPop(this.root);
    }
    
    
    //--- Action sessionAction
    
    public loginAction(): void {
        xStackReset(this.root, new LandingVG(this.root, this.root));
    }
    
    public logOut(session: Session): void {
        const it_83 = session.user;
        if (it_83 !== null) {
            const token_84 = Notifications.INSTANCE.notificationToken.value;
            if (token_84 !== null) {
                it_83.fcmToken.bulkDelete(condition<FcmToken>((it: PropChain<FcmToken, FcmToken>): Condition<FcmToken> => (xPropChainEq<FcmToken, string>(xPropChain_idGet(it), token_84))))
                    .subscribe((it: number): void => {}, (it: any): void => {});
            }
        }
        getSecurePreferences().clear();
        this.loginAction();
    }
    
    //--- Body End
}
export namespace RootVG {
    //! Declares com.lightningkite.template.vg.RootVG.Companion
    export class Companion {
        private constructor() {
        }
        public static INSTANCE = new Companion();
        
        public instance: RootVG;
    }
}
