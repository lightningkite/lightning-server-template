// Package: com.lightningkite.template.vg
// Generated by Khrysalis - this file will be overwritten.
import { Strings } from '../../resources/R'
import { RootBinding } from '../../resources/layouts/RootBinding'
import { xPropChainTermsAgreedGet } from '../../shared/UserFields'
import { User } from '../../shared/models'
import { ServerOption, ServerOptions } from '../api/ServerOptions'
import { AnonymousSession, Session, UserSession } from '../models/UserSession'
import { PreferenceKeys } from '../utils/PreferenceKeys'
import { getSecurePreferences } from '../utils/preferences'
import { LandingVG } from './LandingVG'
import { LoadingDialogVG } from './LoadingDialogVG'
import { SessionVG } from './SessionVG'
import { TermsVG } from './TermsVG'
import { Instant } from '@js-joda/core'
import { printStackTrace, runOrNull } from '@lightningkite/khrysalis-runtime'
import { Modification, PropChain, modification, xPropChainAssign } from '@lightningkite/lightning-server'
import { EntryPoint, HasBackActionDefaults, ViewGenerator, ViewGeneratorStack, doOnSubscribe, not, onThrottledEventDo, reverse, showDialog, showInSwapCustom, subscribeAutoDispose, viewVisible, xStackPop, xStackPush, xStackReset } from '@lightningkite/rxjs-plus'
import { ForegroundNotificationHandler, ForegroundNotificationHandlerResult } from '@lightningkite/rxjs-plus/fcm'
import { findOr } from 'iter-tools-es'
import { BehaviorSubject, Observable, SubscriptionLike, of } from 'rxjs'
import { map, tap } from 'rxjs/operators'

//! Declares com.lightningkite.template.vg.RootVG
export class RootVG implements ViewGenerator, EntryPoint, ForegroundNotificationHandler {
    public static implementsViewGenerator = true;
    public static implementsEntryPoint = true;
    public static implementsHasBackAction = true;
    public static implementsForegroundNotificationHandler = true;
    public constructor() {
        RootVG.Companion.INSTANCE.instance = this;
        this.dialog = new BehaviorSubject([]);
        this.root = new BehaviorSubject([]);
        const serverName = PreferenceKeys.INSTANCE.server;;
        const option = ((): (ServerOption | null) => {
            if (serverName === null || serverName === undefined) { return null }
            return ((it: string): (ServerOption | null) => (ServerOptions.INSTANCE.getOptionByName(it)))(serverName)
        })();;
        const jwt = PreferenceKeys.INSTANCE.session;;
        if (option !== null && jwt !== null) {
            ((): Observable<void> => {
                const temp7 = (): void => {
                    this.dialog.next([]);
                };
                return this.login(option!, jwt)
                    .pipe(doOnSubscribe((it: SubscriptionLike): void => {
                    xStackReset(this.dialog, new LoadingDialogVG());
                }))
                    .pipe(tap(temp7, temp7))
            })()
                .subscribe((it: void): void => {}, (it: any): void => {
                printStackTrace(it);
                showDialog(Strings.generic_error);
                this.loginAction();
            });
        } else {
            this.loginAction();
        };
    }
    
    public handleNotificationInForeground(map: Map<string, string>): ForegroundNotificationHandlerResult {
        return ForegroundNotificationHandlerResult.ShowNotification;
    }
    
    
    
    
    
    public handleDeepLink(schema: string, host: string, path: string, params: Map<string, string>): void {
        console.log("Handling deep link!");
        console.log(`${schema}://${host}${path}?${params}`);
        
        const option = findOr(null, (it: ServerOption): boolean => ((it.api.httpUrl.indexOf(host) != -1)), ServerOptions.INSTANCE.availableServers);
        
        const jwt_20 = (params.get("jwt") ?? null);
        if (jwt_20 !== null) {
            console.log(`OPTION: ${option}`);
            if (option === null) {
                showDialog(Strings.deep_link_was_invalid_server);
            } else {
                ((): Observable<void> => {
                    const temp28 = (): void => {
                        this.dialog.next([]);
                    };
                    return this.login(option!, jwt_20)
                        .pipe(doOnSubscribe((it: SubscriptionLike): void => {
                        xStackReset(this.dialog, new LoadingDialogVG());
                    }))
                        .pipe(tap(temp28, temp28))
                })()
                    .subscribe((it: void): void => {}, (it: any): void => {
                    showDialog(Strings.deep_link_was_invalid_credentials);
                });
            }
        }
        
    }
    
    public login(server: ServerOption, token: (string | null)): Observable<void> {
        return ((): Observable<void> => {
            if (token === null) {
                xStackReset(this.root, new SessionVG(this.mainStack, new Session(new AnonymousSession(server.api), null)));
                return of(undefined);
            } else {
                const session = new UserSession(server.api, token!);
                return session.api.auth.getSelf(session.userToken).pipe(tap((user: User): void => {
                    PreferenceKeys.INSTANCE.server = server.name;
                    PreferenceKeys.INSTANCE.session = token;
                    if (user.termsAgreed.compareTo(Instant.EPOCH) > 0) {
                        this.dialog.next([]);
                        xStackReset(this.root, new SessionVG(this.mainStack, new Session(new AnonymousSession(server.api), session)));
                    } else {
                        xStackPush(this.root, new TermsVG((): void => {
                            session.api.user.modify(user._id, modification<User>((it: PropChain<User, User>): Modification<User> => (xPropChainAssign<User, Instant>(xPropChainTermsAgreedGet(it), Instant.now()))), token)
                                .subscribe((it: User): void => {
                                    console.log(it);
                                }, (it: any): void => {
                                    printStackTrace(it);
                            });
                            this.dialog.next([]);
                            xStackReset(this.root, new SessionVG(this.mainStack, new Session(new AnonymousSession(server.api), session)));
                        }));
                    }
                })).pipe(map((it: User): void => {
                    return undefined;
                }));
            }
        })();
    }
    
    public readonly dialog: ViewGeneratorStack;
    
    public readonly root: ViewGeneratorStack;
    
    //! Declares com.lightningkite.template.vg.RootVG.mainStack
    public get mainStack(): ViewGeneratorStack { return this.root; }
    
    
    public generate(dependency: Window): HTMLElement {
        
        const xml = RootBinding.inflate();
        
        //--- Set Up xml.content (overwritten on flow generation)
        this.root.pipe(showInSwapCustom(xml.content, dependency, undefined));
        
        //--- Set Up xml.backButton
        const showBackButton = this.root.pipe(map((it: Array<ViewGenerator>): boolean => (it.length > 1)));
        showBackButton.pipe(subscribeAutoDispose(xml.backButton, viewVisible));
        showBackButton.pipe(subscribeAutoDispose(xml.backButton, reverse("disabled", not)));
        onThrottledEventDo(xml.backButton, 'click', (): void => {
            this.backButtonClick();
        });
        
        //--- Set Up xml.dialog (overwritten on flow generation)
        this.dialog.pipe(showInSwapCustom(xml.dialog, dependency, undefined));
        
        //--- Generate End (overwritten on flow generation)
        
        return xml.root;
    }
    
    
    
    //--- Actions
    
    public backButtonClick(): void {
        xStackPop(this.root);
    }
    
    
    //--- Action sessionAction
    
    public loginAction(): void {
        xStackReset(this.root, new LandingVG(this.root, this.root));
    }
    
    public logOut(): void {
        getSecurePreferences().clear();
        this.loginAction();
    }
    
    //--- Body End
    public onBackPressed(): boolean { return HasBackActionDefaults.onBackPressed(this); }
}
export namespace RootVG {
    //! Declares com.lightningkite.template.vg.RootVG.Companion
    export class Companion {
        private constructor() {
        }
        public static INSTANCE = new Companion();
        
        public instance: RootVG;
    }
}
